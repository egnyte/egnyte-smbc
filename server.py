""" Module for the SmbcServer class which encapsulates the synchronous
    samba ops functionality
"""

import os
import re
import json
import httplib
import logging
import cherrypy

from multiprocessing import Process

from smb.smb_list import SmbList
from smb.smb import (SmbPermissionsException, SmbObjectNotFoundException,
                     SmbTimedOutException, SmbConnectionException,
                     InvalidSmbConfigException, SERVER_LOGGER)
from pool_worker import mask_password


MOUNT_POINT = "/v1"
CONF_FILE = "/opt/egnyte/smbc-service/confs/server.conf"
SERVER_ACCESS_LOGGER = "serveraccess"


class SmbcServer(Process):
    """ Exposes a REST api which can be used to execute
        smb operations synchronously
    """
    def __init__(self):
        super(SmbcServer, self).__init__()
        self.ppid = None
        self.re = re.compile("(&service_password=.+)")                      # Matches request params that look like &service_password=something....
        self.logger = logging.getLogger(SERVER_LOGGER)
        self.access_logger = logging.getLogger(SERVER_ACCESS_LOGGER)

    def run(self):
        self.ppid = os.getppid()
        self.logger.info("Smbc server started with pid %s and ppid %s", self.pid, self.ppid)

        cherrypy.log.error_log.propagate = False
        cherrypy.log.access_log.propagate = False
        cherrypy.quickstart(self, MOUNT_POINT, CONF_FILE)

    @cherrypy.expose
    def list(self, **kwargs):
        """ Lists a folder tree starting at the path provided by the config in
            kwargs
            Output is streamed back to the client.
            Any smb errors are converted to appropriate http errors

            On error, returns appropriate status and a JSON response that looks
            like this: { "message" : "Error message" }
            On success returns a 200 OK with no "message" JSON
            Instead, the JSON generated by the smb list call is streamed back
            to the client.
        """
        result = {}
        list_job = None
        output_name = None

        cherrypy.response.status = httplib.OK
        cherrypy.response.headers['Content-Type'] = 'text/plain'

        # Parameters are UTF-8 by default, encode to byte strings
        kwargs = dict((k.encode("utf-8"), v.encode("utf-8")) for (k, v) in kwargs.items())

        try:
            list_job = SmbList(kwargs)
            self.logger.info("Running job with configuration as %r", mask_password(kwargs))
            list_job.execute()
            output_name = list_job.get_output_file_name()
        except InvalidSmbConfigException as e:
            cherrypy.response.status = httplib.BAD_REQUEST
            self.logger.exception("Invalid parameters provided for synchronous list call")
            result["message"] = e.message
        except SmbPermissionsException as e:
            cherrypy.response.status = httplib.UNAUTHORIZED
            self.logger.exception("Incorrect permissions for synchronous list call")
            result["message"] = "Smb permissions error: " + e.message
        except SmbObjectNotFoundException as e:
            cherrypy.response.status = httplib.NOT_FOUND
            self.logger.exception("Could not find object for synchronous list call")
            result["message"] = "Smb object not found error: " + e.message
        except SmbTimedOutException as e:
            cherrypy.response.status = httplib.REQUEST_TIMEOUT
            self.logger.exception("Smb operation timed out for synchronous list call")
            result["message"] = "Smb operation timed out: " + e.message
        except SmbConnectionException as e:
            cherrypy.response.status = httplib.SERVICE_UNAVAILABLE
            self.logger.exception("Connection error for synchronous list call")
            result["message"] = "Smb connection error: " + e.message

        # Mask the password before logging
        access_log_message = cherrypy.request.request_line
        matches = self.re.search(access_log_message)
        if matches:
            matched = matches.group(0)
            end = matched.find("&", 1)
            pass_string = matched[:end] 
            access_log_message = access_log_message.replace(pass_string, "&service_password=*********")
        access_log_message = access_log_message + " " + str(cherrypy.response.status)
        self.access_logger.info(access_log_message)

        if list_job:
            list_job.close()
            # In case the job was interrupted, explicitly call del to
            # indicate that resources can be freed
            del list_job

        if result:
            return json.dumps(result, ensure_ascii=False)

        def stream():
            # Open output file and stream the JSON data
            with open(output_name, "r") as jdata:
                for line in jdata:
                    yield line
        return stream()

    list._cp_config = {'response.stream': True}
